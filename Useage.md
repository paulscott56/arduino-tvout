# This information only applies to versions of the library prior to Beta 1.0 #
# Hardware Connections #

![http://farm5.static.flickr.com/4033/4718446356_c99447f4cd.jpg](http://farm5.static.flickr.com/4033/4718446356_c99447f4cd.jpg)


Arduino connections:
  * pin8 must be connected to video
    * Will change to pin 7!!! already has in pre-release svn
  * pin9 must be connected to sync. Hard coded Not changable
Arduino Mega connection:
  * pin11 must be connected to sync
  * pin12 must be connected to video
    * Will change!!!

# Changing the Resolution #

## Version [R4](https://code.google.com/p/arduino-tvout/source/detail?r=4) and up ##

Resolution changes may be done as follows:
TV.begin(mode,hres,vres);
There are limits to this see the description of begin(mode,hres,vres).

## Versions up to and including [R3](https://code.google.com/p/arduino-tvout/source/detail?r=3) ##

[R3](https://code.google.com/p/arduino-tvout/source/detail?r=3) should be used for slightly more user execution time, slightly less memory usage, and much smaller flash usage, otherwise use the latest version.

Open up video\_properties.h and change the lines:
  * #define _RESOLUTION\_HORIZONTAL 	128
  * #define_RESOLUTION\_VERTICAL 	96
To the desired resolution.
There are a few restrictions to this however:
  * _RESOLUTION\_HORIZONTAL must be set to a multiple of 8.
  * `(_RESOLUTION_HORIZONTAL/8)*_RESOLUTION_VERTICAL` must be smaller than the amount of SRAM the Arduino has, It also must leave some memory for the user applications and the library to run.
  * 160 is currently the maximum supported resolution, Higher is possible but it will require the use of a whole port rather than pin. EX: the analog pins may be all used to output video, but none could be used for any other output.
  * In the future I do plan to implement an easer way to change the resolution._

### Description of what each method does: ###

  * begin(mode)
    * Clears the screen and starts generating video @ 128x96
    * mode:
      * _PAL: selects PAL output
      *_NTSC: selects NTSC output
    * Returns(char):
      * 0: if the function completed correctly.
      * 4: if there is not enough memory for the resolution.
  * begin(mode,hres,vres)
    * Clears the screen and starts generating video
    * mode:
      * _PAL: selects PAL output
      *_NTSC: selects NTSC output
    * hres:
      * Horizontal resolution to output must be divisible by 8 and be with the range of 104-152
      * pre-release svn using a standard arduino(needs quick video pin change for sanguino/mega) the upper limit is now 240 pixels.
    * vres:
      * Vertical resolution
      * PAL vres <= 260
      * NTSC vres <= 216
    * Returns(char):
      * 0: if the function completed correctly.
      * 1: if hres was not divisible by 8
      * 2: if hres was to large to render(hardware limit)
      * 3: if vres is to large for selected mode
      * 4: if there is not enough memory for the resolution
      * 5: if hres is not a supported resolution(software limit)
  * pause()
    * Will pause Rendering of video giving back full cpu time.
    * Sync pulses will continue to be generated by the hardware.
  * resume()
    * Restarts the rendering process.
  * clear\_screen()
    * sets the screen to be completely black.
    * This is a macro: fill(0)
  * invert()
    * Inverts the color of the whole screen.
    * This is a macro: fill(2)
  * fill(color)
    * color:
      * 0: BLACK
      * 1: WHITE
      * 2: INVERT
  * hres()
    * Returns the Horizontal resolution as an unsigned char.
  * vres()
    * Returns the Vertical resolution as an unsigned char.
  * char\_line()
    * returns the number of printable characters per line as a char.
  * delay(x)
    * delay an x number of frames.
      * NTSC: An x of 60 gives 1 second of delay.
      * PAL: An x of 50 gives 1 second of delay.
  * set\_pixel(x,y,c)
    * sets a pixel at (x,y)
    * c determines what color the point is set to.
      * c=0 BLACK
      * c=1 WHITE
      * c=2 INVERT
  * get\_pixel(x,y)
    * Gets the color of a pixel, returns an unsigned char.
      * return=0 BLACK
      * return=1 WHITE
  * draw\_line(x0,y0,x1,y1,c)
    * Draw a line from (x0,y0) to (x1,y1)
    * c determines what color the line is set to.
      * c=0 black
      * c=1 white
      * c=2 invert color of this pixel
  * draw\_box(x0,y0,x1,y1,c,d,e,f)
    * See the source this is going to change
    * Will be split into:
      * draw\_rbox() for a rounded rectangle
      * draw\_box() for a regular rectangle
  * draw\_circle(x0,y0,radius,c,d,h)
    * See the source this is going to change
  * fs\_bitmap()
    * Draws a bitmap defined in the library to be expanded on...
  * select\_font(f)
    * f:
      * _3X5: 3x5 font really a 4x6
      *_5X7: 5x7 font really a 6x8 default selection.
      * _8X8: 8x8 font
  * print\_char(x,y,c)
    * Print the character c at (x,y)
  * print\_str(x,y,str)
    * Print the null terminated string str at (x,y)_

The following macros exist to maintain compatibility with earlier versions of the library:
  * The macro.
    * What it evaluates to.
  * start\_render(mode)
    * begin(mode)
  * pause\_render()
    * pause()
  * resume\_render()
    * resume()
  * horz\_res()
    * hres()
  * vert\_res()
    * vres()
  * delay\_frame(x)
    * delay(x)